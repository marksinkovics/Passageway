<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>AsyncSocket Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 858)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">PWServer framework </a></h1>
				<a id="developerHome" href="../index.html">MSCodeFactory</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">AsyncSocket Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/CRData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRData</option>
	
	<option value="//api/name/CRLFData">&nbsp;&nbsp;&nbsp;&nbsp;+ CRLFData</option>
	
	<option value="//api/name/LFData">&nbsp;&nbsp;&nbsp;&nbsp;+ LFData</option>
	
	<option value="//api/name/ZeroData">&nbsp;&nbsp;&nbsp;&nbsp;+ ZeroData</option>
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/acceptOnInterface:port:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnInterface:port:error:</option>
	
	<option value="//api/name/acceptOnPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- acceptOnPort:error:</option>
	
	<option value="//api/name/addRunLoopMode:">&nbsp;&nbsp;&nbsp;&nbsp;- addRunLoopMode:</option>
	
	<option value="//api/name/canSafelySetDelegate">&nbsp;&nbsp;&nbsp;&nbsp;- canSafelySetDelegate</option>
	
	<option value="//api/name/connectToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:error:</option>
	
	<option value="//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:viaInterfaceAddress:withTimeout:error:</option>
	
	<option value="//api/name/connectToAddress:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:withTimeout:error:</option>
	
	<option value="//api/name/connectToHost:onPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:error:</option>
	
	<option value="//api/name/connectToHost:onPort:withTimeout:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:withTimeout:error:</option>
	
	<option value="//api/name/connectedAddress">&nbsp;&nbsp;&nbsp;&nbsp;- connectedAddress</option>
	
	<option value="//api/name/connectedHost">&nbsp;&nbsp;&nbsp;&nbsp;- connectedHost</option>
	
	<option value="//api/name/connectedPort">&nbsp;&nbsp;&nbsp;&nbsp;- connectedPort</option>
	
	<option value="//api/name/delegate">&nbsp;&nbsp;&nbsp;&nbsp;- delegate</option>
	
	<option value="//api/name/description">&nbsp;&nbsp;&nbsp;&nbsp;- description</option>
	
	<option value="//api/name/disconnect">&nbsp;&nbsp;&nbsp;&nbsp;- disconnect</option>
	
	<option value="//api/name/disconnectAfterReading">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReading</option>
	
	<option value="//api/name/disconnectAfterReadingAndWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterReadingAndWriting</option>
	
	<option value="//api/name/disconnectAfterWriting">&nbsp;&nbsp;&nbsp;&nbsp;- disconnectAfterWriting</option>
	
	<option value="//api/name/enablePreBuffering">&nbsp;&nbsp;&nbsp;&nbsp;- enablePreBuffering</option>
	
	<option value="//api/name/getCFReadStream">&nbsp;&nbsp;&nbsp;&nbsp;- getCFReadStream</option>
	
	<option value="//api/name/getCFSocket">&nbsp;&nbsp;&nbsp;&nbsp;- getCFSocket</option>
	
	<option value="//api/name/getCFWriteStream">&nbsp;&nbsp;&nbsp;&nbsp;- getCFWriteStream</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:</option>
	
	<option value="//api/name/initWithDelegate:userData:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:userData:</option>
	
	<option value="//api/name/isConnected">&nbsp;&nbsp;&nbsp;&nbsp;- isConnected</option>
	
	<option value="//api/name/isIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4</option>
	
	<option value="//api/name/isIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6</option>
	
	<option value="//api/name/localAddress">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress</option>
	
	<option value="//api/name/localHost">&nbsp;&nbsp;&nbsp;&nbsp;- localHost</option>
	
	<option value="//api/name/localPort">&nbsp;&nbsp;&nbsp;&nbsp;- localPort</option>
	
	<option value="//api/name/moveToRunLoop:">&nbsp;&nbsp;&nbsp;&nbsp;- moveToRunLoop:</option>
	
	<option value="//api/name/progressOfReadReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfReadReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/progressOfWriteReturningTag:bytesDone:total:">&nbsp;&nbsp;&nbsp;&nbsp;- progressOfWriteReturningTag:bytesDone:total:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:maxLength:tag:</option>
	
	<option value="//api/name/readDataToData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToData:withTimeout:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataToLength:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataToLength:withTimeout:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:buffer:bufferOffset:tag:</option>
	
	<option value="//api/name/readDataWithTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- readDataWithTimeout:tag:</option>
	
	<option value="//api/name/removeRunLoopMode:">&nbsp;&nbsp;&nbsp;&nbsp;- removeRunLoopMode:</option>
	
	<option value="//api/name/runLoopModes">&nbsp;&nbsp;&nbsp;&nbsp;- runLoopModes</option>
	
	<option value="//api/name/setDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:</option>
	
	<option value="//api/name/setRunLoopModes:">&nbsp;&nbsp;&nbsp;&nbsp;- setRunLoopModes:</option>
	
	<option value="//api/name/setUserData:">&nbsp;&nbsp;&nbsp;&nbsp;- setUserData:</option>
	
	<option value="//api/name/startTLS:">&nbsp;&nbsp;&nbsp;&nbsp;- startTLS:</option>
	
	<option value="//api/name/unreadData">&nbsp;&nbsp;&nbsp;&nbsp;- unreadData</option>
	
	<option value="//api/name/userData">&nbsp;&nbsp;&nbsp;&nbsp;- userData</option>
	
	<option value="//api/name/writeData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- writeData:withTimeout:tag:</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				



<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRData">CRData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/CRLFData">CRLFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/LFData">LFData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/ZeroData">ZeroData</a></span></li>
	
</ul></li>



<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnInterface:port:error:">acceptOnInterface:port:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/addRunLoopMode:">addRunLoopMode:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/canSafelySetDelegate">canSafelySetDelegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:">connectToAddress:viaInterfaceAddress:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:withTimeout:error:">connectToAddress:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:withTimeout:error:">connectToHost:onPort:withTimeout:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedAddress">connectedAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedHost">connectedHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedPort">connectedPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegate">delegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/description">description</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnect">disconnect</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReading">disconnectAfterReading</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterReadingAndWriting">disconnectAfterReadingAndWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/disconnectAfterWriting">disconnectAfterWriting</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/enablePreBuffering">enablePreBuffering</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getCFReadStream">getCFReadStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getCFSocket">getCFSocket</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getCFWriteStream">getCFWriteStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:">initWithDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:userData:">initWithDelegate:userData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isConnected">isConnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4">isIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6">isIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress">localAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost">localHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort">localPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/moveToRunLoop:">moveToRunLoop:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">progressOfReadReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">progressOfWriteReturningTag:bytesDone:total:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">readDataToData:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">readDataToData:withTimeout:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToData:withTimeout:tag:">readDataToData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataToLength:withTimeout:tag:">readDataToLength:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">readDataWithTimeout:buffer:bufferOffset:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readDataWithTimeout:tag:">readDataWithTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/removeRunLoopMode:">removeRunLoopMode:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/runLoopModes">runLoopModes</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:">setDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setRunLoopModes:">setRunLoopModes:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setUserData:">setUserData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/startTLS:">startTLS:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/unreadData">unreadData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/userData">userData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeData:withTimeout:tag:">writeData:withTimeout:tag:</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="AsyncSocket Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">AsyncSocket Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">AsyncSocket.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:">&ndash;&nbsp;initWithDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:userData:">&ndash;&nbsp;initWithDelegate:userData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/description">&ndash;&nbsp;description</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
		<span class="tooltip"><p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate<br/>
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/canSafelySetDelegate">&ndash;&nbsp;canSafelySetDelegate</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:">&ndash;&nbsp;setDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setUserData:">&ndash;&nbsp;setUserData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getCFSocket">&ndash;&nbsp;getCFSocket</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getCFReadStream">&ndash;&nbsp;getCFReadStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getCFWriteStream">&ndash;&nbsp;getCFWriteStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnPort:error:">&ndash;&nbsp;acceptOnPort:error:</a></code>
		<span class="tooltip"><p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).<br/>
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/acceptOnInterface:port:error:">&ndash;&nbsp;acceptOnInterface:port:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option<br/>
of specifying which interface to listen on. So, for example, if you were writing code for a server that<br/>
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it<br/>
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.<br/>
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that<br/>
the socket only accept connections from the local machine.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
		<span class="tooltip"><p>Connects to the given host and port.<br/>
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:withTimeout:error:">&ndash;&nbsp;connectToHost:onPort:withTimeout:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
		<span class="tooltip"><p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:withTimeout:error:</a></code>
		<span class="tooltip"><p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:">&ndash;&nbsp;connectToAddress:viaInterfaceAddress:withTimeout:error:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnect">&ndash;&nbsp;disconnect</a></code>
		<span class="tooltip"><p>Disconnects immediately. Any pending reads or writes are dropped.<br/>
If the socket is not already disconnected, the onSocketDidDisconnect <a href="#//api/name/delegate">delegate</a> method<br/>
will be called immediately, before this method returns.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReading">&ndash;&nbsp;disconnectAfterReading</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterWriting">&ndash;&nbsp;disconnectAfterWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/disconnectAfterReadingAndWriting">&ndash;&nbsp;disconnectAfterReadingAndWriting</a></code>
		<span class="tooltip"><p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
		<span class="tooltip"><p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedPort">&ndash;&nbsp;connectedPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort">&ndash;&nbsp;localPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
		<span class="tooltip"><p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
		<span class="tooltip"><p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:tag:">&ndash;&nbsp;readDataWithTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:tag:">&ndash;&nbsp;readDataToLength:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToLength:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:tag:">&ndash;&nbsp;readDataToData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:">&ndash;&nbsp;readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</a></code>
		<span class="tooltip"><p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeData:withTimeout:tag:">&ndash;&nbsp;writeData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfReadReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfReadReturningTag:bytesDone:total:</a></code>
		<span class="tooltip"><p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).<br/>
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/progressOfWriteReturningTag:bytesDone:total:">&ndash;&nbsp;progressOfWriteReturningTag:bytesDone:total:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/startTLS:">&ndash;&nbsp;startTLS:</a></code>
		<span class="tooltip"><p>Secures the connection using SSL/TLS.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/enablePreBuffering">&ndash;&nbsp;enablePreBuffering</a></code>
		<span class="tooltip"><p>For handling readDataToData requests, data is necessarily read from the socket in small increments.<br/>
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and<br/>
store any overflow in a small internal buffer.<br/>
This is termed pre-buffering, as some data may be read for you before you ask for it.<br/>
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/moveToRunLoop:">&ndash;&nbsp;moveToRunLoop:</a></code>
		<span class="tooltip"><p>When you create an AsyncSocket, it is added to the runloop of the current thread.<br/>
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setRunLoopModes:">&ndash;&nbsp;setRunLoopModes:</a></code>
		<span class="tooltip"><p>Allows you to configure which run loop modes the socket uses.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/addRunLoopMode:">&ndash;&nbsp;addRunLoopMode:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/removeRunLoopMode:">&ndash;&nbsp;removeRunLoopMode:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/runLoopModes">&ndash;&nbsp;runLoopModes</a></code>
		<span class="tooltip"><p>Returns the current run loop modes the AsyncSocket instance is operating in.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/unreadData">&ndash;&nbsp;unreadData</a></code>
		<span class="tooltip"><p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read<br/>
any data that&rsquo;s left on the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRLFData">+&nbsp;CRLFData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/CRData">+&nbsp;CRData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/LFData">+&nbsp;LFData</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/ZeroData">+&nbsp;ZeroData</a></code>
		
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/CRData" title="CRData"></a>
	<h3 class="subsubtitle method-title">CRData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/CRLFData" title="CRLFData"></a>
	<h3 class="subsubtitle method-title">CRLFData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)CRLFData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/LFData" title="LFData"></a>
	<h3 class="subsubtitle method-title">LFData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)LFData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/ZeroData" title="ZeroData"></a>
	<h3 class="subsubtitle method-title">ZeroData</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (NSData *)ZeroData</code></div>

    
</div>
						
					</div>
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/acceptOnInterface:port:error:" title="acceptOnInterface:port:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnInterface:port:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option<br/>
of specifying which interface to listen on. So, for example, if you were writing code for a server that<br/>
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it<br/>
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.<br/>
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that<br/>
the socket only accept connections from the local machine.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnInterface:(NSString *)<em>interface</em> port:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> with the additional option<br/>
of specifying which interface to listen on. So, for example, if you were writing code for a server that<br/>
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it<br/>
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.<br/>
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that<br/>
the socket only accept connections from the local machine.</p>

<p>To accept connections on any interface pass nil, or simply use the <a href="#//api/name/acceptOnPort:error:">acceptOnPort:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/acceptOnPort:error:" title="acceptOnPort:error:"></a>
	<h3 class="subsubtitle method-title">acceptOnPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).<br/>
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)acceptOnPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Tells the socket to begin listening and accepting connections on the given port.<br/>
When a connection comes in, the AsyncSocket instance will call the various <a href="#//api/name/delegate">delegate</a> methods (see above).<br/>
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/addRunLoopMode:" title="addRunLoopMode:"></a>
	<h3 class="subsubtitle method-title">addRunLoopMode:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)addRunLoopMode:(NSString *)<em>runLoopMode</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/canSafelySetDelegate" title="canSafelySetDelegate"></a>
	<h3 class="subsubtitle method-title">canSafelySetDelegate</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)canSafelySetDelegate</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.<br/>
For example, a NSData object returned from NSNetService&rsquo;s addresses method.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:<br/>
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];<br/>
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:" title="connectToAddress:viaInterfaceAddress:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:viaInterfaceAddress:withTimeout:error:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> viaInterfaceAddress:(NSData *)<em>interfaceAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:withTimeout:error:" title="connectToAddress:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects to the given host and port.<br/>
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects to the given host and port.<br/>
The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;)</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:withTimeout:error:" title="connectToHost:onPort:withTimeout:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:withTimeout:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>hostname</em> onPort:(UInt16)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>This method is the same as <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> with an additional timeout option.<br/>
To not time out use a negative time interval, or simply use the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="subsubtitle method-title">connectedAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote address to which this socket is connected,<br/>
specified as a sockaddr structure wrapped in a NSData object.</p>

<p>See also the <a href="#//api/name/connectedHost">connectedHost</a>, <a href="#//api/name/connectedPort">connectedPort</a>, <a href="#//api/name/localHost">localHost</a> and <a href="#//api/name/localPort">localPort</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="subsubtitle method-title">connectedHost</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.<br/>
The host will be an IP address.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedPort" title="connectedPort"></a>
	<h3 class="subsubtitle method-title">connectedPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (UInt16)connectedPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="subsubtitle method-title">delegate</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate<br/>
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Use &ldquo;canSafelySetDelegate&rdquo; to see if there is any pending business (reads and writes) with the current delegate<br/>
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/description" title="description"></a>
	<h3 class="subsubtitle method-title">description</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)description</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnect" title="disconnect"></a>
	<h3 class="subsubtitle method-title">disconnect</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects immediately. Any pending reads or writes are dropped.<br/>
If the socket is not already disconnected, the onSocketDidDisconnect <a href="#//api/name/delegate">delegate</a> method<br/>
will be called immediately, before this method returns.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnect</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects immediately. Any pending reads or writes are dropped.<br/>
If the socket is not already disconnected, the onSocketDidDisconnect delegate method<br/>
will be called immediately, before this method returns.</p>

<p>Please note the recommended way of releasing an AsyncSocket instance (e.g. in a dealloc method)<br/>
[asyncSocket setDelegate:nil];<br/>
[asyncSocket disconnect];<br/>
[asyncSocket release];</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReading" title="disconnectAfterReading"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReading</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReading</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending writes.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterReadingAndWriting" title="disconnectAfterReadingAndWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterReadingAndWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterReadingAndWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending reads and writes have completed.<br/>
After calling this, the read and write methods will do nothing.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/disconnectAfterWriting" title="disconnectAfterWriting"></a>
	<h3 class="subsubtitle method-title">disconnectAfterWriting</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)disconnectAfterWriting</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Disconnects after all pending writes have completed.<br/>
After calling this, the read and write methods will do nothing.<br/>
The socket will <a href="#//api/name/disconnect">disconnect</a> even if there are still pending reads.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/enablePreBuffering" title="enablePreBuffering"></a>
	<h3 class="subsubtitle method-title">enablePreBuffering</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.<br/>
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and<br/>
store any overflow in a small internal buffer.<br/>
This is termed pre-buffering, as some data may be read for you before you ask for it.<br/>
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)enablePreBuffering</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>For handling readDataToData requests, data is necessarily read from the socket in small increments.<br/>
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and<br/>
store any overflow in a small internal buffer.<br/>
This is termed pre-buffering, as some data may be read for you before you ask for it.<br/>
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</p>

<p>The default pre-buffering state is controlled by the DEFAULT_PREBUFFERING definition.<br/>
It is highly recommended one leave this set to YES.</p>

<p>This method exists in case pre-buffering needs to be disabled by default for some unforeseen reason.<br/>
In that case, this method exists to allow one to easily enable pre-buffering when ready.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/getCFReadStream" title="getCFReadStream"></a>
	<h3 class="subsubtitle method-title">getCFReadStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)getCFReadStream</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getCFSocket" title="getCFSocket"></a>
	<h3 class="subsubtitle method-title">getCFSocket</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFSocketRef)getCFSocket</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getCFWriteStream" title="getCFWriteStream"></a>
	<h3 class="subsubtitle method-title">getCFWriteStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFWriteStreamRef)getCFWriteStream</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)init</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:" title="initWithDelegate:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:userData:" title="initWithDelegate:userData:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:userData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>delegate</em> userData:(long)<em>userData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="subsubtitle method-title">isConnected</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="subsubtitle method-title">isIPv4</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether the socket is IPv4 or IPv6.<br/>
An accepting socket may be both.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="subsubtitle method-title">localAddress</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="subsubtitle method-title">localHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort" title="localPort"></a>
	<h3 class="subsubtitle method-title">localPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (UInt16)localPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/moveToRunLoop:" title="moveToRunLoop:"></a>
	<h3 class="subsubtitle method-title">moveToRunLoop:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>When you create an AsyncSocket, it is added to the runloop of the current thread.<br/>
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)moveToRunLoop:(NSRunLoop *)<em>runLoop</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>When you create an AsyncSocket, it is added to the runloop of the current thread.<br/>
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</p>

<p>If a new socket is accepted, the <a href="#//api/name/delegate">delegate</a> method onSocket:wantsRunLoopForNewSocket: is called to<br/>
allow you to place the socket on a separate thread. This works best in conjunction with a thread pool design.</p>

<p>If, however, you need to move the socket to a separate thread at a later time, this<br/>
method may be used to accomplish the task.</p>

<p>This method must be called from the thread/runloop the socket is currently running on.</p>

<p>Note: After calling this method, all further method calls to this object should be done from the given runloop.<br/>
Also, all <a href="#//api/name/delegate">delegate</a> calls will be sent on the given runloop.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfReadReturningTag:bytesDone:total:" title="progressOfReadReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfReadReturningTag:bytesDone:total:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).<br/>
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (float)progressOfReadReturningTag:(long *)<em>tag</em> bytesDone:(NSUInteger *)<em>done</em> total:(NSUInteger *)<em>total</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).<br/>
&ldquo;tag&rdquo;, &ldquo;done&rdquo; and &ldquo;total&rdquo; will be filled in if they aren&rsquo;t NULL.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/progressOfWriteReturningTag:bytesDone:total:" title="progressOfWriteReturningTag:bytesDone:total:"></a>
	<h3 class="subsubtitle method-title">progressOfWriteReturningTag:bytesDone:total:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (float)progressOfWriteReturningTag:(long *)<em>tag</em> bytesDone:(NSUInteger *)<em>done</em> total:(NSUInteger *)<em>total</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If maxLength is zero, no length restriction is enforced.<br/>
Otherwise if maxLength bytes are read without completing the read,<br/>
it is treated similarly to a timeout - the socket is closed with a AsyncSocketReadMaxedOutError.<br/>
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass a maxLength parameter that is less than the length of the data parameter,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.<br/>
If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for<br/>
a character, the read will prematurely end.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:" title="readDataToData:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for<br/>
a character, the read will prematurely end.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:maxLength:tag:" title="readDataToData:withTimeout:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If maxLength is zero, no length restriction is enforced.<br/>
Otherwise if maxLength bytes are read without completing the read,<br/>
it is treated similarly to a timeout - the socket is closed with a AsyncSocketReadMaxedOutError.<br/>
The read will complete successfully if exactly maxLength bytes are read and the given data is found at the end.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.<br/>
If you pass a maxLength parameter that is less than the length of the data parameter,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for<br/>
a character, the read will prematurely end.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToData:withTimeout:tag:" title="readDataToData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads bytes until (and including) the passed &ldquo;data&rdquo; parameter, which acts as a separator.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If you pass nil or zero-length data as the &ldquo;data&rdquo; parameter,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>To read a line from the socket, use the line separator (e.g. CRLF for HTTP, see below) as the &ldquo;data&rdquo; parameter.<br/>
Note that this method is not character-set aware, so if a separator can occur naturally as part of the encoding for<br/>
a character, the read will prematurely end.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:" title="readDataToLength:withTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.<br/>
If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataToLength:withTimeout:tag:" title="readDataToLength:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataToLength:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the given number of bytes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataToLength:(NSUInteger)<em>length</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the given number of bytes.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>

<p>If the length is 0, this method does nothing and the <a href="#//api/name/delegate">delegate</a> is not called.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:" title="readDataWithTimeout:buffer:bufferOffset:maxLength:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> maxLength:(NSUInteger)<em>length</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.<br/>
A maximum of length bytes will be read.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, a buffer will automatically be created for you.<br/>
If maxLength is zero, no length restriction is enforced.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:buffer:bufferOffset:tag:" title="readDataWithTimeout:buffer:bufferOffset:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:buffer:bufferOffset:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> buffer:(NSMutableData *)<em>buffer</em> bufferOffset:(NSUInteger)<em>offset</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.<br/>
The bytes will be appended to the given byte buffer starting at the given offset.<br/>
The given buffer will automatically be increased in size if needed.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.<br/>
If the buffer if nil, the socket will create a buffer for you.</p>

<p>If the bufferOffset is greater than the length of the given buffer,<br/>
the method will do nothing, and the <a href="#//api/name/delegate">delegate</a> will not be called.</p>

<p>If you pass a buffer, you must not alter it in any way while AsyncSocket is using it.<br/>
After completion, the data returned in onSocket:didReadData:withTag: will be a subset of the given buffer.<br/>
That is, it will reference the bytes that were appended to the given buffer.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readDataWithTimeout:tag:" title="readDataWithTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">readDataWithTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Reads the first available bytes that become available on the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)readDataWithTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Reads the first available bytes that become available on the socket.</p>

<p>If the timeout value is negative, the read operation will not use a timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/removeRunLoopMode:" title="removeRunLoopMode:"></a>
	<h3 class="subsubtitle method-title">removeRunLoopMode:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)removeRunLoopMode:(NSString *)<em>runLoopMode</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/runLoopModes" title="runLoopModes"></a>
	<h3 class="subsubtitle method-title">runLoopModes</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the current run loop modes the AsyncSocket instance is operating in.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSArray *)runLoopModes</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the current run loop modes the AsyncSocket instance is operating in.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:" title="setDelegate:"></a>
	<h3 class="subsubtitle method-title">setDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setRunLoopModes:" title="setRunLoopModes:"></a>
	<h3 class="subsubtitle method-title">setRunLoopModes:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Allows you to configure which run loop modes the socket uses.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)setRunLoopModes:(NSArray *)<em>runLoopModes</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Allows you to configure which run loop modes the socket uses.<br/>
The default set of run loop modes is NSDefaultRunLoopMode.</p>

<p>If you&rsquo;d like your socket to continue operation during other modes, you may want to add modes such as<br/>
NSModalPanelRunLoopMode or NSEventTrackingRunLoopMode. Or you may simply want to use NSRunLoopCommonModes.</p>

<p>Accepted sockets will automatically inherit the same run loop modes as the listening socket.</p>

<p>Note: NSRunLoopCommonModes is defined in 10.5. For previous versions one can use kCFRunLoopCommonModes.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setUserData:" title="setUserData:"></a>
	<h3 class="subsubtitle method-title">setUserData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setUserData:(long)<em>userData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/startTLS:" title="startTLS:"></a>
	<h3 class="subsubtitle method-title">startTLS:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Secures the connection using SSL/TLS.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)startTLS:(NSDictionary *)<em>tlsSettings</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Secures the connection using SSL/TLS.</p>

<p>This method may be called at any time, and the TLS handshake will occur after all pending reads and writes<br/>
are finished. This allows one the option of sending a protocol dependent StartTLS message, and queuing<br/>
the upgrade to TLS at the same time, without having to wait for the write to finish.<br/>
Any reads or writes scheduled after this method is called will occur over the secured connection.</p>

<p>The possible keys and values for the TLS settings are well documented.<br/>
Some possible keys are:<br/>
- kCFStreamSSLLevel<br/>
- kCFStreamSSLAllowsExpiredCertificates<br/>
- kCFStreamSSLAllowsExpiredRoots<br/>
- kCFStreamSSLAllowsAnyRoot<br/>
- kCFStreamSSLValidatesCertificateChain<br/>
- kCFStreamSSLPeerName<br/>
- kCFStreamSSLCertificates<br/>
- kCFStreamSSLIsServer</p>

<p>Please refer to Apple&rsquo;s documentation for associated values, as well as other possible keys.</p>

<p>If you pass in nil or an empty dictionary, the default settings will be used.</p>

<p>The default settings will check to make sure the remote party&rsquo;s certificate is signed by a<br/>
trusted 3rd party certificate agency (e.g. verisign) and that the certificate is not expired.<br/>
However it will not verify the name on the certificate unless you<br/>
give it a name to verify against via the kCFStreamSSLPeerName key.<br/>
The security implications of this are important to understand.<br/>
Imagine you are attempting to create a secure connection to MySecureServer.com,<br/>
but your socket gets directed to MaliciousServer.com because of a hacked DNS server.<br/>
If you simply use the default settings, and MaliciousServer.com has a valid certificate,<br/>
the default settings will not detect any problems since the certificate is valid.<br/>
To properly secure your connection in this particular scenario you<br/>
should set the kCFStreamSSLPeerName property to &ldquo;MySecureServer.com&rdquo;.<br/>
If you do not know the peer name of the remote host in advance (for example, you&rsquo;re not sure<br/>
if it will be &ldquo;domain.com&rdquo; or &ldquo;www.domain.com&rdquo;), then you can use the default settings to validate the<br/>
certificate, and then use the X509Certificate class to verify the issuer after the socket has been secured.<br/>
The X509Certificate class is part of the CocoaAsyncSocket open source project.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/unreadData" title="unreadData"></a>
	<h3 class="subsubtitle method-title">unreadData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read<br/>
any data that&rsquo;s left on the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)unreadData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read<br/>
any data that&rsquo;s left on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="subsubtitle method-title">userData</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (long)userData</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/writeData:withTimeout:tag:" title="writeData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">writeData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)writeData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Writes data to the socket, and calls the <a href="#//api/name/delegate">delegate</a> when finished.</p>

<p>If you pass in nil or zero-length data, this method does nothing and the <a href="#//api/name/delegate">delegate</a> will not be called.<br/>
If the timeout value is negative, the write operation will not use a timeout.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">AsyncSocket.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2013 MSCodeFactory. All rights reserved. (Last updated: 2013-05-04)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 858)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>